#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "SpectrumGenerationParams.h"
#include "complex.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba32f) writeonly uniform image2D spectrumTex;
layout(binding = 1) readonly uniform params_t {
    SpectrumGenerationParams params;
};

// using this as a uniform distribution number gnerator
float hash(uint n) 
{
	n = (n << 13U) ^ n;
    n = n * (n * n * 15731U + 789221U) + 1376312589U;
    return float(n & uint(0x7fffffffU))/float(0x7fffffff);
}

// using Box - Muller here
vec2 uniformToGaussian(float uniFirst, float uniSecond) {
    float root = sqrt(-2.0 * log(uniFirst));
    float theta = kTwoPi * uniSecond;
    return vec2(root * cos(theta), root * sin(theta));
}

float phillipsSpectrum(vec2 k) {
    float lengthK = length(k);
    if (lengthK < 0.00001) {
        return 0.0;
    }
    // variables are exactly as in paper (GPGPU FFT Ocean Simulation p.17)
    float A = params.amplitude;
    float V = params.windSpeed;
    float L = V * V / 9.81;
    vec2 w = normalize(params.windDirection);
    float kdotw = dot(normalize(k), w);

    return A * (exp(-1.0 / ((lengthK * L) * (lengthK * L))) / (lengthK * lengthK * lengthK * lengthK)) * kdotw * kdotw;
}

vec2 spectrumAmplitude(vec2 k, vec2 rands) {
    return rands * sqrt(phillipsSpectrum(k) / 2.0);
}

void main(void) {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    uvec2 spectrumTexSize = imageSize(spectrumTex);
    if (texCoord.x >= spectrumTexSize.x || texCoord.y >= spectrumTexSize.y) {
        return;
    }

    vec2 center = vec2(spectrumTexSize) / 2.0;
    vec2 k = (vec2(texCoord) - center) * kTwoPi / params.patchSize;

    float lengthK = length(k);
    if (lengthK < params.lowCutoff || lengthK > params.highCutoff) {
        imageStore(spectrumTex, texCoord, vec4(0));
        return;
    }

    uint seed = texCoord.x + spectrumTexSize.x + texCoord.y * spectrumTexSize.y + params.seed;
    vec4 uniformRandomSamples = 
        vec4(hash(seed),
            hash(seed * 2),
            hash(seed * 3),
            hash(seed * 4)
        );
    vec2 firstGauss = uniformToGaussian(uniformRandomSamples.x, uniformRandomSamples.y);
    vec2 secondGauss = uniformToGaussian(uniformRandomSamples.z, uniformRandomSamples.w);

    vec2 positiveKWave = spectrumAmplitude(k, vec2(firstGauss.x, secondGauss.y));
    vec2 negativeKWave = spectrumAmplitude(-k, vec2(firstGauss.y, secondGauss.x));

    imageStore(spectrumTex, texCoord, vec4(positiveKWave, negativeKWave));     
}