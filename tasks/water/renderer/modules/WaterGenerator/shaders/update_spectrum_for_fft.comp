#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "SpectrumGenerationParams.h"
#include "complex.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba32f) readonly uniform image2D initialSpectrumTex;
layout(binding = 1, rgba32f) writeonly uniform image2D updatedSpectrumSlopeTex;
layout(binding = 2, rgba32f) writeonly uniform image2D updatedSpectrumDisplacementTex;

layout(binding = 6) readonly uniform params_t {
    SpectrumGenerationParams params;
};

layout(push_constant) uniform push_constant_t {
    float time;
};

void main(void) {
    ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
    uvec2 spectrumTexSize = imageSize(initialSpectrumTex);
    if (texCoord.x >= spectrumTexSize.x || texCoord.y >= spectrumTexSize.y) {
        return;
    }

    vec4 signal = imageLoad(initialSpectrumTex, texCoord);
    vec2 positiveKWave = signal.xy;
    vec2 negativeKWave = signal.zw;

    vec2 center = vec2(spectrumTexSize) / 2.0;

    vec2 k = (vec2(texCoord) - center) * kTwoPi / params.patchSize;
    float lengthK = length(k);
    float lengthKRcp = 1 / lengthK;
    if (lengthK < params.lowCutoff) {
        lengthKRcp = 1.0;
    }
    
    float phase = kTwoPi / params.wavePeriod;
    float dispersion = floor(sqrt(params.gravity * lengthK) / phase) * phase * time;
    vec2 exponent = euler(dispersion);

    vec2 fullWave = complexMult(positiveKWave, exponent) + complexMult(negativeKWave, vec2(exponent.x, -exponent.y));
    vec2 dFullWave = vec2(-fullWave.y, fullWave.x);

    // first derivatives
    vec2 dispX = dFullWave * k.x * lengthKRcp;
    vec2 dispY = fullWave;
    vec2 dispZ = dFullWave * k.y * lengthKRcp;

    // second dderivatives
    vec2 dispX_dx = -fullWave * k.x * k.x * lengthKRcp;
    vec2 dispY_dx = dFullWave * k.x;
    vec2 dispZ_dx = -fullWave * k.y * k.x * lengthKRcp;

    vec2 dispY_dz = dFullWave * k.y;
    vec2 dispZ_dz = -fullWave * k.y * k.y * lengthKRcp;

    vec2 displacementX = vec2(dispX.x - dispZ.y, dispX.y + dispZ.x);
    vec2 displacementZ = vec2(dispY.x - dispZ_dx.y, dispY.y + dispZ_dx.x);

    vec2 slopeX = vec2(dispY_dx.x - dispY_dz.y, dispY_dx.y + dispY_dz.x);
    vec2 slopeZ = vec2(dispX_dx.x - dispZ_dz.y, dispX_dx.y + dispZ_dz.x);

    imageStore(updatedSpectrumDisplacementTex, texCoord, vec4(displacementX, displacementZ));
    imageStore(updatedSpectrumSlopeTex, texCoord, vec4(slopeX, slopeZ));
}