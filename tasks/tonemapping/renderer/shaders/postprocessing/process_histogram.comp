#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive : require

#include "tonemapping_utils.glsl"

layout(local_size_x = 128) in; // upper bound of bins amount, increase if needed

layout(binding = 0) buffer histogramBuffer {
    uint histogramBins[];
};

layout(binding = 1) buffer distributionBuffer {
    float distributionBins[];
};

layout(binding = 2) buffer histogramInfo_t {
    float binStepSize; // absolute
    float minWorldLuminance;    // relative
    float maxWorldLuminance;    // relative
    float minWorldBrightness;
    float maxWorldBrightness;
};

layout(push_constant) uniform params {
    uint len; 
};

shared uint totalAmount;
shared uint newTotalAmount;
shared uint trimmings;

void recalculateAmount(uint currentBin) {
    if (currentBin == 0) {
        newTotalAmount = 0;
        trimmings = 0;
    }
    memoryBarrierShared();
    barrier();

    atomicAdd(newTotalAmount, histogramBins[currentBin]);

    memoryBarrierShared();
    barrier();
}

void recalculateDistribution(uint currentBin, uint localNewTotal) {
    distributionBins[currentBin] = 0;

    memoryBarrierBuffer();
    barrier();

    uint accumulated = 0;
    for (int i = 0; i <= currentBin; i++) {
        accumulated += histogramBins[i];
    }

    distributionBins[currentBin] = (localNewTotal == 0 ? 1.0 : float(accumulated) / float(localNewTotal));

    memoryBarrierBuffer();
    barrier();
}

float deltaLuminance(float luminance) {
    float brightness = log(luminance) / log10;
    // from bonus
    float brightnessDelta = 
        brightness < -3.94 ? -3.81 
        : (
            brightness < -1.44 ? pow(0.405 * brightness + 1.6, 2.18)
            : (
                brightness < -0.0184 ? (brightness - 1.345)
                : (
                    brightness < 1.9 ? (pow(0.249 * brightness + 0.65 , 2.7) - 1.67)
                    : (brightness - 2.205)
                )
            )
        );
    return pow(10, brightnessDelta);
}

float calculateCeiling(float displayLuminance, float worldLuminance, uint amount) {
    return deltaLuminance(displayLuminance) * worldLuminance 
        / (displayLuminance * deltaLuminance(worldLuminance))
        * float(amount) * binStepSize 
        / (maxDisplayLuminance - minDisplayLuminance);
}

void processHistogram(uint currentBin) {
    uint localTotalAmount = totalAmount;
    const uint tolerance = uint(0.025 * localTotalAmount);
    do {

        recalculateAmount(currentBin);

        uint localNewTotalAmount = newTotalAmount;
        
        recalculateDistribution(currentBin, localNewTotalAmount);

        float displayLuminance = minDisplayLuminance + (maxDisplayLuminance - minDisplayLuminance) * distributionBins[currentBin];
        float worldLuminance = (float(currentBin) + 0.5) * binStepSize + minDisplayLuminance;

        if (localNewTotalAmount < tolerance) {
            return;
        }

        uint ceiling =
                uint(calculateCeiling(
                    displayLuminance,
                    worldLuminance, 
                    localNewTotalAmount
                ));

        if (histogramBins[currentBin] > ceiling) {
            uint trimmed = histogramBins[currentBin] - ceiling;
            atomicAdd(trimmings, trimmed);
            histogramBins[currentBin] = ceiling;
        }

        memoryBarrierShared();
        memoryBarrierBuffer();
        barrier();
    } while (trimmings > tolerance);
}

void main() {
    uint currentBin = gl_GlobalInvocationID.x;
    if (currentBin >= len) {
        return;
    }
    if (currentBin == 0) {
        totalAmount = 0;
    }

    memoryBarrierShared();
    barrier();
    
    atomicAdd(totalAmount, histogramBins[currentBin]);

    memoryBarrierShared();
    barrier();

    processHistogram(currentBin);
}