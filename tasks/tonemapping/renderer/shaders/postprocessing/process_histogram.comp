#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 128) in; // upper bound of bins amount, increase if needed

layout(binding = 0) buffer histogramBuffer {
    int histogramBins[];
};

layout(binding = 1) buffer distributionBuffer {
    float distributionBins[]; //float
};

layout(binding = 2) buffer histogramInfo_t {
    float binStepSize;
    float minWorldLuminance;    // relative
    float maxWorldLuminance;    // relative
    float minWorldBrightness;
    float maxWorldBrightness;
};

layout(push_constant) uniform params {
    uint len; 
};

// const float log10 = 2.302585092994; //precompute log(10)

// // relative, hardcode from monitor spec
// const float maxDisplayLuminance = 1.0; // 350
// const float minDisplayLuminance = 0.001; //0.35
// //maybe precompute
// const float maxDisplayBrightness = log(maxDisplayLuminance); 
// const float minDisplayBrightness = log(minDisplayLuminance);

// // absolute, hardcode from monitor spec
// const float absMaxDisplayLuminance = 350;
// const float absMinDisplayLuminance = 0.35;
// //maybe precompute
// const float absMaxDisplayBrightness = log(absMaxDisplayLuminance); 
// const float absMinDisplayBrightness = log(absMinDisplayLuminance);

shared uint totalAmount;
// shared uint newTotalAmount;
// shared int trimmings;

// void recalculateAmount(uint currentBin) {
//     if (currentBin == 0) {
//         newTotalAmount = 0;
//         trimmings = 0;
//     }
//     barrier();
//     atomicAdd(newTotalAmount, histogramBins[currentBin]);
// }

// void recalculateDistribution(uint currentBin) {
//     distributionBins[currentBin] = 0;
//     uint accumulated = 0;
//     barrier();

//     for (int i = 0; i < currentBin; i++) {
//         accumulated += histogramBins[i];
//     }
//     distributionBins[currentBin] = float(accumulated) / float(newTotalAmount);
//     barrier(); //maybe too many barriers
// }

// float deltaLuminance(float luminance) {
//     float brightness = log(luminance) / log10;
//     // from bonus
//     float brightnessDelta = 
//         brightness < -3.94 ? -3.81 
//         : (
//             brightness < -1.44 ? pow(0.405 * brightness + 1.6, 2.18)
//             : (
//                 brightness < -0.0184 ? (brightness - 1.345)
//                 : (
//                     brightness < 1.9 ? (pow(0.249 * brightness + 0.65 , 2.7) - 1.67)
//                     : (brightness - 2.205)
//                 )
//             )
//         );
//     return pow(10, brightnessDelta);
// }

// float calculateCeiling(float displayLuminance, float worldLuminance) {
//     return deltaLuminance(displayLuminance) * worldLuminance 
//         / (displayLuminance * deltaLuminance(worldLuminance))
//         * newTotalAmount * binStepSize 
//         / (maxDisplayBrightness - minDisplayBrightness);
// }

// void processHistogram(uint currentBin) {
//     const float tolerance = 0.025;
//     do {

//         recalculateAmount(currentBin);

//         if (newTotalAmount < uint(floor(totalAmount * tolerance))) {
//             return;
//         }

//         float displayBrightness = 
//             minDisplayBrightness
//             + (maxDisplayBrightness - minDisplayBrightness)
//             * distributionBins[currentBin];

//         float ceiling = 
//             calculateCeiling(
//                 exp(displayBrightness),
//                 exp(currentBin * binStepSize + minWorldBrightness) // world luminance estimate
//             );
        
//         int clippedCeiling = int(floor(ceiling));

//         if (histogramBins[currentBin] > clippedCeiling) {
//             int trimmed = histogramBins[currentBin] - clippedCeiling;
//             atomicAdd(trimmings, trimmed);
//             histogramBins[currentBin] = clippedCeiling;
//         }

//         barrier();

//         recalculateDistribution(currentBin);
//     } while (float(trimmings) / float(totalAmount) > tolerance);
// }

void main() {
    uint currentBin = gl_GlobalInvocationID.x;
    if (currentBin >= len) {
        return;
    }
    if (currentBin == 0) {
        totalAmount = 0;
    }

    memoryBarrierShared();
    barrier();
    
    atomicAdd(totalAmount, histogramBins[currentBin]);

    memoryBarrierShared();
    barrier();
    int accumulated = 0;
    for (int i = 0; i <= currentBin; i++) {
        accumulated += histogramBins[i];
    }
    distributionBins[currentBin] = float(accumulated) / float(totalAmount);
    // recalculateAmount(currentBin);
    // recalculateDistribution(currentBin);
    // processHistogram(currentBin);
}