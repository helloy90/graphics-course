#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 128) in; // upper bound of bins amount, increase if needed

layout(binding = 0) buffer histogramBuffer {
    uint histogramBins[];
};

layout(binding = 1) buffer distributionBuffer {
    float distributionBins[]; //float
};

layout(binding = 2) buffer histogramInfo_t {
    float binStepSize;
    float minWorldLuminance;    // relative
    float maxWorldLuminance;    // relative
    float minWorldBrightness;
    float maxWorldBrightness;
};

layout(push_constant) uniform params {
    uint len; 
};

// const float log10 = 2.302585092994; //precompute log(10)

const float minDisplayLuminance = 0.0001;
const float maxDisplayLuminance = 1;

shared uint totalAmount;
shared uint newTotalAmount;
shared uint trimmings;

void recalculateAmount(uint currentBin) {
    if (currentBin == 0) {
        newTotalAmount = 0;
        trimmings = 0;
    }
    memoryBarrierShared();
    barrier();

    atomicAdd(newTotalAmount, histogramBins[currentBin]);

    memoryBarrierShared();
    barrier();
}

void recalculateDistribution(uint currentBin, uint localNewTotal) {
    distributionBins[currentBin] = 0;

    memoryBarrierBuffer();
    barrier();

    uint accumulated = 0;
    for (int i = 0; i <= currentBin; i++) {
        accumulated += histogramBins[i];
    }

    distributionBins[currentBin] = (localNewTotal == 0 ? 1.0 : float(accumulated) / float(localNewTotal));

    memoryBarrierBuffer();
    barrier();
}

// float deltaLuminance(float luminance) {
//     float brightness = log(luminance) / log10;
//     // from bonus
//     float brightnessDelta = 
//         brightness < -3.94 ? -3.81 
//         : (
//             brightness < -1.44 ? pow(0.405 * brightness + 1.6, 2.18)
//             : (
//                 brightness < -0.0184 ? (brightness - 1.345)
//                 : (
//                     brightness < 1.9 ? (pow(0.249 * brightness + 0.65 , 2.7) - 1.67)
//                     : (brightness - 2.205)
//                 )
//             )
//         );
//     return pow(10, brightnessDelta);
// }

// float calculateCeiling(float displayLuminance, float worldLuminance, uint amount) {
//     return deltaLuminance(displayLuminance) * worldLuminance 
//         / (displayLuminance * deltaLuminance(worldLuminance))
//         * float(amount) * binStepSize 
//         / (maxDisplayLuminance - minDisplayLuminance);
// }

void processHistogram(uint currentBin) {
    uint localTotalAmount = totalAmount;
    const uint tolerance = uint(0.025 * localTotalAmount);
    do {

        recalculateAmount(currentBin);

        uint localNewTotalAmount = newTotalAmount;
        
        recalculateDistribution(currentBin, localNewTotalAmount);


        if (localNewTotalAmount < tolerance) {
            return;
        }


        uint ceiling = uint(float(localNewTotalAmount) *  binStepSize / (maxDisplayLuminance - minDisplayLuminance));

        if (histogramBins[currentBin] > ceiling) {
            uint trimmed = histogramBins[currentBin] - ceiling;
            atomicAdd(trimmings, trimmed);
            histogramBins[currentBin] = ceiling;
        }

        memoryBarrierShared();
        memoryBarrierBuffer();
        barrier();
    } while (trimmings > tolerance);
}

void main() {
    uint currentBin = gl_GlobalInvocationID.x;
    if (currentBin >= len) {
        return;
    }
    if (currentBin == 0) {
        totalAmount = 0;
    }

    memoryBarrierShared();
    barrier();
    
    atomicAdd(totalAmount, histogramBins[currentBin]);

    memoryBarrierShared();
    barrier();

    processHistogram(currentBin);
}